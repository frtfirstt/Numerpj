{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ParenthesisNode';\nvar dependencies = ['Node'];\nexport var createParenthesisNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\r\n   * @constructor ParenthesisNode\r\n   * @extends {Node}\r\n   * A parenthesis node describes manual parenthesis from the user input\r\n   * @param {Node} content\r\n   * @extends {Node}\r\n   */\n\n  function ParenthesisNode(content) {\n    if (!(this instanceof ParenthesisNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (!isNode(content)) {\n      throw new TypeError('Node expected for parameter \"content\"');\n    }\n\n    this.content = content;\n  }\n\n  ParenthesisNode.prototype = new Node();\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\n  ParenthesisNode.prototype.isParenthesisNode = true;\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\n\n  ParenthesisNode.prototype._compile = function (math, argNames) {\n    return this.content._compile(math, argNames);\n  };\n  /**\r\n   * Get the content of the current Node.\r\n   * @return {Node} content\r\n   * @override\r\n   **/\n\n\n  ParenthesisNode.prototype.getContent = function () {\n    return this.content.getContent();\n  };\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\n\n\n  ParenthesisNode.prototype.forEach = function (callback) {\n    callback(this.content, 'content', this);\n  };\n  /**\r\n   * Create a new ParenthesisNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\r\n   * @returns {ParenthesisNode} Returns a clone of the node\r\n   */\n\n\n  ParenthesisNode.prototype.map = function (callback) {\n    var content = callback(this.content, 'content', this);\n    return new ParenthesisNode(content);\n  };\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {ParenthesisNode}\r\n   */\n\n\n  ParenthesisNode.prototype.clone = function () {\n    return new ParenthesisNode(this.content);\n  };\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  ParenthesisNode.prototype._toString = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '(' + this.content.toString(options) + ')';\n    }\n\n    return this.content.toString(options);\n  };\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\n\n\n  ParenthesisNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ParenthesisNode',\n      content: this.content\n    };\n  };\n  /**\r\n   * Instantiate an ParenthesisNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"ParenthesisNode\", \"content\": ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {ParenthesisNode}\r\n   */\n\n\n  ParenthesisNode.fromJSON = function (json) {\n    return new ParenthesisNode(json.content);\n  };\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  ParenthesisNode.prototype.toHTML = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return this.content.toHTML(options);\n  };\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  ParenthesisNode.prototype._toTex = function (options) {\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\n      return \"\\\\left(\".concat(this.content.toTex(options), \"\\\\right)\");\n    }\n\n    return this.content.toTex(options);\n  };\n\n  return ParenthesisNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/big49/Desktop/clone2/Numerpj/node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js"],"names":["isNode","factory","name","dependencies","createParenthesisNode","_ref","Node","ParenthesisNode","content","SyntaxError","TypeError","prototype","type","isParenthesisNode","_compile","math","argNames","getContent","forEach","callback","map","clone","_toString","options","parenthesis","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","concat","toTex","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'ParenthesisNode';\r\nvar dependencies = ['Node'];\r\nexport var createParenthesisNode = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n\r\n  /**\r\n   * @constructor ParenthesisNode\r\n   * @extends {Node}\r\n   * A parenthesis node describes manual parenthesis from the user input\r\n   * @param {Node} content\r\n   * @extends {Node}\r\n   */\r\n  function ParenthesisNode(content) {\r\n    if (!(this instanceof ParenthesisNode)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    } // validate input\r\n\r\n\r\n    if (!isNode(content)) {\r\n      throw new TypeError('Node expected for parameter \"content\"');\r\n    }\r\n\r\n    this.content = content;\r\n  }\r\n\r\n  ParenthesisNode.prototype = new Node();\r\n  ParenthesisNode.prototype.type = 'ParenthesisNode';\r\n  ParenthesisNode.prototype.isParenthesisNode = true;\r\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\r\n\r\n  ParenthesisNode.prototype._compile = function (math, argNames) {\r\n    return this.content._compile(math, argNames);\r\n  };\r\n  /**\r\n   * Get the content of the current Node.\r\n   * @return {Node} content\r\n   * @override\r\n   **/\r\n\r\n\r\n  ParenthesisNode.prototype.getContent = function () {\r\n    return this.content.getContent();\r\n  };\r\n  /**\r\n   * Execute a callback for each of the child nodes of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype.forEach = function (callback) {\r\n    callback(this.content, 'content', this);\r\n  };\r\n  /**\r\n   * Create a new ParenthesisNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\r\n   * @returns {ParenthesisNode} Returns a clone of the node\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype.map = function (callback) {\r\n    var content = callback(this.content, 'content', this);\r\n    return new ParenthesisNode(content);\r\n  };\r\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {ParenthesisNode}\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype.clone = function () {\r\n    return new ParenthesisNode(this.content);\r\n  };\r\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype._toString = function (options) {\r\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\r\n      return '(' + this.content.toString(options) + ')';\r\n    }\r\n\r\n    return this.content.toString(options);\r\n  };\r\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'ParenthesisNode',\r\n      content: this.content\r\n    };\r\n  };\r\n  /**\r\n   * Instantiate an ParenthesisNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"ParenthesisNode\", \"content\": ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {ParenthesisNode}\r\n   */\r\n\r\n\r\n  ParenthesisNode.fromJSON = function (json) {\r\n    return new ParenthesisNode(json.content);\r\n  };\r\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype.toHTML = function (options) {\r\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\r\n      return '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + this.content.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n    }\r\n\r\n    return this.content.toHTML(options);\r\n  };\r\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  ParenthesisNode.prototype._toTex = function (options) {\r\n    if (!options || options && !options.parenthesis || options && options.parenthesis === 'keep') {\r\n      return \"\\\\left(\".concat(this.content.toTex(options), \"\\\\right)\");\r\n    }\r\n\r\n    return this.content.toTex(options);\r\n  };\r\n\r\n  return ParenthesisNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}