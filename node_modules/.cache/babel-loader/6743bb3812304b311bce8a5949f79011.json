{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'stirlingS2';\nvar dependencies = ['typed', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'factorial', 'combinations', 'isNegative', 'isInteger', 'larger'];\nexport var createStirlingS2 = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    addScalar,\n    subtract,\n    multiplyScalar,\n    divideScalar,\n    pow,\n    factorial,\n    combinations,\n    isNegative,\n    isInteger,\n    larger\n  } = _ref;\n  /**\r\n   * The Stirling numbers of the second kind, counts the number of ways to partition\r\n   * a set of n labelled objects into k nonempty unlabelled subsets.\r\n   * stirlingS2 only takes integer arguments.\r\n   * The following condition must be enforced: k <= n.\r\n   *\r\n   *  If n = k or k = 1, then s(n,k) = 1\r\n   *\r\n   * Syntax:\r\n   *\r\n   *   math.stirlingS2(n, k)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.stirlingS2(5, 3) //returns 25\r\n   *\r\n   * See also:\r\n   *\r\n   *    bellNumbers\r\n   *\r\n   * @param {Number | BigNumber} n    Total number of objects in the set\r\n   * @param {Number | BigNumber} k    Number of objects in the subset\r\n   * @return {Number | BigNumber}     S(n,k)\r\n   */\n\n  return typed(name, {\n    'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {\n      if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {\n        throw new TypeError('Non-negative integer value expected in function stirlingS2');\n      } else if (larger(k, n)) {\n        throw new TypeError('k must be less than or equal to n in function stirlingS2');\n      } // 1/k! Sum(i=0 -> k) [(-1)^(k-i)*C(k,j)* i^n]\n\n\n      var kFactorial = factorial(k);\n      var result = 0;\n\n      for (var i = 0; i <= k; i++) {\n        var negativeOne = pow(-1, subtract(k, i));\n        var kChooseI = combinations(k, i);\n        var iPower = pow(i, n);\n        result = addScalar(result, multiplyScalar(multiplyScalar(kChooseI, iPower), negativeOne));\n      }\n\n      return divideScalar(result, kFactorial);\n    }\n  });\n});","map":{"version":3,"sources":["C:/Users/first/Desktop/numer/Numerpj/node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js"],"names":["factory","name","dependencies","createStirlingS2","_ref","typed","addScalar","subtract","multiplyScalar","divideScalar","pow","factorial","combinations","isNegative","isInteger","larger","numberBigNumberNumberBigNumber","n","k","TypeError","kFactorial","result","i","negativeOne","kChooseI","iPower"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,YAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,WAAV,EAAuB,UAAvB,EAAmC,gBAAnC,EAAqD,cAArD,EAAqE,KAArE,EAA4E,WAA5E,EAAyF,cAAzF,EAAyG,YAAzG,EAAuH,WAAvH,EAAoI,QAApI,CAAnB;AACA,OAAO,IAAIC,gBAAgB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAsBE,IAAD,IAAU;AACjF,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,SAFE;AAGFC,IAAAA,QAHE;AAIFC,IAAAA,cAJE;AAKFC,IAAAA,YALE;AAMFC,IAAAA,GANE;AAOFC,IAAAA,SAPE;AAQFC,IAAAA,YARE;AASFC,IAAAA,UATE;AAUFC,IAAAA,SAVE;AAWFC,IAAAA;AAXE,MAYAX,IAZJ;AAcA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAOC,KAAK,CAACJ,IAAD,EAAO;AACjB,8CAA0C,SAASe,8BAAT,CAAwCC,CAAxC,EAA2CC,CAA3C,EAA8C;AACtF,UAAI,CAACJ,SAAS,CAACG,CAAD,CAAV,IAAiBJ,UAAU,CAACI,CAAD,CAA3B,IAAkC,CAACH,SAAS,CAACI,CAAD,CAA5C,IAAmDL,UAAU,CAACK,CAAD,CAAjE,EAAsE;AACpE,cAAM,IAAIC,SAAJ,CAAc,4DAAd,CAAN;AACD,OAFD,MAEO,IAAIJ,MAAM,CAACG,CAAD,EAAID,CAAJ,CAAV,EAAkB;AACvB,cAAM,IAAIE,SAAJ,CAAc,0DAAd,CAAN;AACD,OALqF,CAKpF;;;AAGF,UAAIC,UAAU,GAAGT,SAAS,CAACO,CAAD,CAA1B;AACA,UAAIG,MAAM,GAAG,CAAb;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIJ,CAArB,EAAwBI,CAAC,EAAzB,EAA6B;AAC3B,YAAIC,WAAW,GAAGb,GAAG,CAAC,CAAC,CAAF,EAAKH,QAAQ,CAACW,CAAD,EAAII,CAAJ,CAAb,CAArB;AACA,YAAIE,QAAQ,GAAGZ,YAAY,CAACM,CAAD,EAAII,CAAJ,CAA3B;AACA,YAAIG,MAAM,GAAGf,GAAG,CAACY,CAAD,EAAIL,CAAJ,CAAhB;AACAI,QAAAA,MAAM,GAAGf,SAAS,CAACe,MAAD,EAASb,cAAc,CAACA,cAAc,CAACgB,QAAD,EAAWC,MAAX,CAAf,EAAmCF,WAAnC,CAAvB,CAAlB;AACD;;AAED,aAAOd,YAAY,CAACY,MAAD,EAASD,UAAT,CAAnB;AACD;AApBgB,GAAP,CAAZ;AAsBD,CA7DmD,CAA7C","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'stirlingS2';\r\nvar dependencies = ['typed', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'factorial', 'combinations', 'isNegative', 'isInteger', 'larger'];\r\nexport var createStirlingS2 = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    typed,\r\n    addScalar,\r\n    subtract,\r\n    multiplyScalar,\r\n    divideScalar,\r\n    pow,\r\n    factorial,\r\n    combinations,\r\n    isNegative,\r\n    isInteger,\r\n    larger\r\n  } = _ref;\r\n\r\n  /**\r\n   * The Stirling numbers of the second kind, counts the number of ways to partition\r\n   * a set of n labelled objects into k nonempty unlabelled subsets.\r\n   * stirlingS2 only takes integer arguments.\r\n   * The following condition must be enforced: k <= n.\r\n   *\r\n   *  If n = k or k = 1, then s(n,k) = 1\r\n   *\r\n   * Syntax:\r\n   *\r\n   *   math.stirlingS2(n, k)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.stirlingS2(5, 3) //returns 25\r\n   *\r\n   * See also:\r\n   *\r\n   *    bellNumbers\r\n   *\r\n   * @param {Number | BigNumber} n    Total number of objects in the set\r\n   * @param {Number | BigNumber} k    Number of objects in the subset\r\n   * @return {Number | BigNumber}     S(n,k)\r\n   */\r\n  return typed(name, {\r\n    'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {\r\n      if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {\r\n        throw new TypeError('Non-negative integer value expected in function stirlingS2');\r\n      } else if (larger(k, n)) {\r\n        throw new TypeError('k must be less than or equal to n in function stirlingS2');\r\n      } // 1/k! Sum(i=0 -> k) [(-1)^(k-i)*C(k,j)* i^n]\r\n\r\n\r\n      var kFactorial = factorial(k);\r\n      var result = 0;\r\n\r\n      for (var i = 0; i <= k; i++) {\r\n        var negativeOne = pow(-1, subtract(k, i));\r\n        var kChooseI = combinations(k, i);\r\n        var iPower = pow(i, n);\r\n        result = addScalar(result, multiplyScalar(multiplyScalar(kChooseI, iPower), negativeOne));\r\n      }\r\n\r\n      return divideScalar(result, kFactorial);\r\n    }\r\n  });\r\n});"]},"metadata":{},"sourceType":"module"}