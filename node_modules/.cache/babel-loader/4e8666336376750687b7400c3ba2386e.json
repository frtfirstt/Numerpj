{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { factory } from '../../../utils/factory.js';\nvar name = 'qr';\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];\nexport var createQr = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    zeros,\n    identity,\n    isZero,\n    equal,\n    sign,\n    sqrt,\n    conj,\n    unaryMinus,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    complex\n  } = _ref;\n  /**\r\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\r\n   * two matrices (`Q`, `R`) where `Q` is an\r\n   * orthogonal matrix and `R` is an upper triangular matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.qr(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [\r\n   *      [1, -1,  4],\r\n   *      [1,  4, -2],\r\n   *      [1,  4,  2],\r\n   *      [1,  -1, 0]\r\n   *    ]\r\n   *    const result = math.qr(m)\r\n   *    // r = {\r\n   *    //   Q: [\r\n   *    //     [0.5, -0.5,   0.5],\r\n   *    //     [0.5,  0.5,  -0.5],\r\n   *    //     [0.5,  0.5,   0.5],\r\n   *    //     [0.5, -0.5,  -0.5],\r\n   *    //   ],\r\n   *    //   R: [\r\n   *    //     [2, 3,  2],\r\n   *    //     [0, 5, -2],\r\n   *    //     [0, 0,  4],\r\n   *    //     [0, 0,  0]\r\n   *    //   ]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    lup, lusolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array\r\n   * for which to get the QR decomposition.\r\n   *\r\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\r\n   * matrix and R: the upper triangular matrix\r\n   */\n\n  return _extends(typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseQR(m); // result\n\n\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  }), {\n    _denseQRimpl\n  });\n\n  function _denseQRimpl(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data; // vars\n\n    var i, j, k;\n    var w = zeros([rows], '');\n\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\r\n       * **k-th Household matrix**\r\n       *\r\n       * The matrix I - 2*v*transpose(v)\r\n       * x     = first column of A\r\n       * x1    = first element of x\r\n       * alpha = x1 / |x1| * |x|\r\n       * e1    = tranpose([1, 0, 0, ...])\r\n       * u     = x - alpha * e1\r\n       * v     = u / |u|\r\n       *\r\n       * Household matrix = I - 2 * v * tranpose(v)\r\n       *\r\n       *  * Initially Q = I and R = A.\r\n       *  * Household matrix is a reflection in a plane normal to v which\r\n       *    will zero out all but the top right element in R.\r\n       *  * Appplying reflection to both Q and R will not change product.\r\n       *  * Repeat this process on the (1,1) minor to get R as an upper\r\n       *    triangular matrix.\r\n       *  * Reflections leave the magnitude of the columns of Q unchanged\r\n       *    so Q remains othoganal.\r\n       *\r\n       */\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n\n        w[k] = 1;\n\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        } // tau = - conj(u1 / alpha)\n\n\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n        /*\r\n         * tau and w have been choosen so that\r\n         *\r\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\r\n         */\n\n        /*\r\n         * -- calculate R = R - tau * w * tranpose(w) * R --\r\n         * Only do calculation with rows k to (rows-1)\r\n         * Additionally columns 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\n\n        for (j = k; j < cols; j++) {\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\n\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          } // calculate the jth element of [tau * transpose(w) * R]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\r\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\r\n         * Q is a square matrix (rows x rows)\r\n         * Only do calculation with columns k to (rows-1)\r\n         * Additionally rows 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\n\n\n        for (i = 0; i < rows; i++) {\n          s = 0.0; // calculate ith element of [Q * w]\n\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          } // calculate the ith element of [tau * Q * w]\n\n\n          s = multiplyScalar(s, tau);\n\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    } // return matrices\n\n\n    return {\n      Q: Q,\n      R: R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n\n  function _denseQR(m) {\n    var ret = _denseQRimpl(m);\n\n    var Rdata = ret.R._data;\n\n    if (m._data.length > 0) {\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\n\n      for (var i = 0; i < Rdata.length; ++i) {\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\n          Rdata[i][j] = zero;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n});","map":{"version":3,"sources":["C:/Users/big49/Desktop/clone2/Numerpj/node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","factory","name","dependencies","createQr","_ref","typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtract","complex","DenseMatrix","m","_denseQR","SparseMatrix","_sparseQR","Array","a","r","Q","valueOf","R","_denseQRimpl","rows","_size","cols","Qdata","_data","clone","Rdata","j","k","w","Math","min","pivot","sgn","conjSgn","alphaSquared","alpha","u1","tau","s","toString","ret","zero","type","Error"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\r\n\r\nimport { factory } from '../../../utils/factory.js';\r\nvar name = 'qr';\r\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];\r\nexport var createQr = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    zeros,\r\n    identity,\r\n    isZero,\r\n    equal,\r\n    sign,\r\n    sqrt,\r\n    conj,\r\n    unaryMinus,\r\n    addScalar,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtract,\r\n    complex\r\n  } = _ref;\r\n\r\n  /**\r\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\r\n   * two matrices (`Q`, `R`) where `Q` is an\r\n   * orthogonal matrix and `R` is an upper triangular matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.qr(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [\r\n   *      [1, -1,  4],\r\n   *      [1,  4, -2],\r\n   *      [1,  4,  2],\r\n   *      [1,  -1, 0]\r\n   *    ]\r\n   *    const result = math.qr(m)\r\n   *    // r = {\r\n   *    //   Q: [\r\n   *    //     [0.5, -0.5,   0.5],\r\n   *    //     [0.5,  0.5,  -0.5],\r\n   *    //     [0.5,  0.5,   0.5],\r\n   *    //     [0.5, -0.5,  -0.5],\r\n   *    //   ],\r\n   *    //   R: [\r\n   *    //     [2, 3,  2],\r\n   *    //     [0, 5, -2],\r\n   *    //     [0, 0,  4],\r\n   *    //     [0, 0,  0]\r\n   *    //   ]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    lup, lusolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array\r\n   * for which to get the QR decomposition.\r\n   *\r\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\r\n   * matrix and R: the upper triangular matrix\r\n   */\r\n  return _extends(typed(name, {\r\n    DenseMatrix: function DenseMatrix(m) {\r\n      return _denseQR(m);\r\n    },\r\n    SparseMatrix: function SparseMatrix(m) {\r\n      return _sparseQR(m);\r\n    },\r\n    Array: function Array(a) {\r\n      // create dense matrix from array\r\n      var m = matrix(a); // lup, use matrix implementation\r\n\r\n      var r = _denseQR(m); // result\r\n\r\n\r\n      return {\r\n        Q: r.Q.valueOf(),\r\n        R: r.R.valueOf()\r\n      };\r\n    }\r\n  }), {\r\n    _denseQRimpl\r\n  });\r\n\r\n  function _denseQRimpl(m) {\r\n    // rows & columns (m x n)\r\n    var rows = m._size[0]; // m\r\n\r\n    var cols = m._size[1]; // n\r\n\r\n    var Q = identity([rows], 'dense');\r\n    var Qdata = Q._data;\r\n    var R = m.clone();\r\n    var Rdata = R._data; // vars\r\n\r\n    var i, j, k;\r\n    var w = zeros([rows], '');\r\n\r\n    for (k = 0; k < Math.min(cols, rows); ++k) {\r\n      /*\r\n       * **k-th Household matrix**\r\n       *\r\n       * The matrix I - 2*v*transpose(v)\r\n       * x     = first column of A\r\n       * x1    = first element of x\r\n       * alpha = x1 / |x1| * |x|\r\n       * e1    = tranpose([1, 0, 0, ...])\r\n       * u     = x - alpha * e1\r\n       * v     = u / |u|\r\n       *\r\n       * Household matrix = I - 2 * v * tranpose(v)\r\n       *\r\n       *  * Initially Q = I and R = A.\r\n       *  * Household matrix is a reflection in a plane normal to v which\r\n       *    will zero out all but the top right element in R.\r\n       *  * Appplying reflection to both Q and R will not change product.\r\n       *  * Repeat this process on the (1,1) minor to get R as an upper\r\n       *    triangular matrix.\r\n       *  * Reflections leave the magnitude of the columns of Q unchanged\r\n       *    so Q remains othoganal.\r\n       *\r\n       */\r\n      var pivot = Rdata[k][k];\r\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\r\n      var conjSgn = conj(sgn);\r\n      var alphaSquared = 0;\r\n\r\n      for (i = k; i < rows; i++) {\r\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\r\n      }\r\n\r\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\r\n\r\n      if (!isZero(alpha)) {\r\n        // first element in vector u\r\n        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)\r\n\r\n        w[k] = 1;\r\n\r\n        for (i = k + 1; i < rows; i++) {\r\n          w[i] = divideScalar(Rdata[i][k], u1);\r\n        } // tau = - conj(u1 / alpha)\r\n\r\n\r\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\r\n        var s = void 0;\r\n        /*\r\n         * tau and w have been choosen so that\r\n         *\r\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\r\n         */\r\n\r\n        /*\r\n         * -- calculate R = R - tau * w * tranpose(w) * R --\r\n         * Only do calculation with rows k to (rows-1)\r\n         * Additionally columns 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\r\n\r\n        for (j = k; j < cols; j++) {\r\n          s = 0.0; // calculate jth element of [tranpose(w) * R]\r\n\r\n          for (i = k; i < rows; i++) {\r\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\r\n          } // calculate the jth element of [tau * transpose(w) * R]\r\n\r\n\r\n          s = multiplyScalar(s, tau);\r\n\r\n          for (i = k; i < rows; i++) {\r\n            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\r\n          }\r\n        }\r\n        /*\r\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\r\n         * Q is a square matrix (rows x rows)\r\n         * Only do calculation with columns k to (rows-1)\r\n         * Additionally rows 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\r\n\r\n\r\n        for (i = 0; i < rows; i++) {\r\n          s = 0.0; // calculate ith element of [Q * w]\r\n\r\n          for (j = k; j < rows; j++) {\r\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\r\n          } // calculate the ith element of [tau * Q * w]\r\n\r\n\r\n          s = multiplyScalar(s, tau);\r\n\r\n          for (j = k; j < rows; ++j) {\r\n            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\r\n          }\r\n        }\r\n      }\r\n    } // return matrices\r\n\r\n\r\n    return {\r\n      Q: Q,\r\n      R: R,\r\n      toString: function toString() {\r\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\r\n      }\r\n    };\r\n  }\r\n\r\n  function _denseQR(m) {\r\n    var ret = _denseQRimpl(m);\r\n\r\n    var Rdata = ret.R._data;\r\n\r\n    if (m._data.length > 0) {\r\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\r\n\r\n      for (var i = 0; i < Rdata.length; ++i) {\r\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\r\n          Rdata[i][j] = zero;\r\n        }\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  function _sparseQR(m) {\r\n    throw new Error('qr not implemented for sparse matrices yet');\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}