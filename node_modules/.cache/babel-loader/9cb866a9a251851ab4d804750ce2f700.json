{"ast":null,"code":"import { isConstantNode, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'derivative';\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createDerivative = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    parse,\n    simplify,\n    equal,\n    isZero,\n    numeric,\n    ConstantNode,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  /**\r\n   * Takes the derivative of an expression expressed in parser Nodes.\r\n   * The derivative will be taken over the supplied variable in the\r\n   * second parameter. If there are multiple variables in the expression,\r\n   * it will return a partial derivative.\r\n   *\r\n   * This uses rules of differentiation which can be found here:\r\n   *\r\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     derivative(expr, variable)\r\n   *     derivative(expr, variable, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.derivative('x^2', 'x')                     // Node {2 * x}\r\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node {2 * 1 * x ^ (2 - 1)\r\n   *     math.derivative('sin(2x)', 'x'))                // Node {2 * cos(2 * x)}\r\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\r\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\r\n   *     const f = math.parse('x^2')\r\n   *     const x = math.parse('x')\r\n   *     math.derivative(f, x)                           // Node {2 * x}\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, parse, evaluate\r\n   *\r\n   * @param  {Node | string} expr           The expression to differentiate\r\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\r\n   * @param  {{simplify: boolean}} [options]\r\n   *                         There is one option available, `simplify`, which\r\n   *                         is true by default. When false, output will not\r\n   *                         be simplified.\r\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\r\n   */\n\n  var derivative = typed('derivative', {\n    'Node, SymbolNode, Object': function NodeSymbolNodeObject(expr, variable, options) {\n      var constNodes = {};\n      constTag(constNodes, expr, variable.name);\n\n      var res = _derivative(expr, constNodes);\n\n      return options.simplify ? simplify(res) : res;\n    },\n    'Node, SymbolNode': function NodeSymbolNode(expr, variable) {\n      return this(expr, variable, {\n        simplify: true\n      });\n    },\n    'string, SymbolNode': function stringSymbolNode(expr, variable) {\n      return this(parse(expr), variable);\n    },\n    'string, SymbolNode, Object': function stringSymbolNodeObject(expr, variable, options) {\n      return this(parse(expr), variable, options);\n    },\n    'string, string': function stringString(expr, variable) {\n      return this(parse(expr), parse(variable));\n    },\n    'string, string, Object': function stringStringObject(expr, variable, options) {\n      return this(parse(expr), parse(variable), options);\n    },\n    'Node, string': function NodeString(expr, variable) {\n      return this(expr, parse(variable));\n    },\n    'Node, string, Object': function NodeStringObject(expr, variable, options) {\n      return this(expr, parse(variable), options);\n    } // TODO: replace the 8 signatures above with 4 as soon as typed-function supports optional arguments\n\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\r\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\r\n      let res = expr\r\n      for (let i = 0; i < order; i++) {\r\n        let constNodes = {}\r\n        constTag(constNodes, expr, variable.name)\r\n        res = _derivative(res, constNodes)\r\n      }\r\n      return res\r\n    }\r\n    */\n\n  });\n  derivative._simplify = true;\n\n  derivative.toTex = function (deriv) {\n    return _derivTex.apply(null, deriv.args);\n  }; // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\n  // NOTE: the optional \"order\" parameter here is currently unused\n\n\n  var _derivTex = typed('_derivTex', {\n    'Node, SymbolNode': function NodeSymbolNode(expr, x) {\n      if (isConstantNode(expr) && typeOf(expr.value) === 'string') {\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\n      } else {\n        return _derivTex(expr.toString(), x.toString(), 1);\n      }\n    },\n    'Node, ConstantNode': function NodeConstantNode(expr, x) {\n      if (typeOf(x.value) === 'string') {\n        return _derivTex(expr, parse(x.value));\n      } else {\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\n      }\n    },\n    'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {\n      return _derivTex(expr.toString(), x.name, order.value);\n    },\n    'string, string, number': function stringStringNumber(expr, x, order) {\n      var d;\n\n      if (order === 1) {\n        d = '{d\\\\over d' + x + '}';\n      } else {\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\n      }\n\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\n    }\n  });\n  /**\r\n   * Does a depth-first search on the expression tree to identify what Nodes\r\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\r\n   * constNodes. Classification is done as follows:\r\n   *\r\n   *   1. ConstantNodes are constants.\r\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\r\n   *      in the subtree it is not constant.\r\n   *\r\n   * @param  {Object} constNodes  Holds the nodes that are constant\r\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param  {string} varName     Variable that we are differentiating\r\n   * @return {boolean}  if node is constant\r\n   */\n  // TODO: can we rewrite constTag into a pure function?\n\n\n  var constTag = typed('constTag', {\n    'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {\n      constNodes[node] = true;\n      return true;\n    },\n    'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {\n      // Treat other variables like constants. For reasoning, see:\n      //   https://en.wikipedia.org/wiki/Partial_derivative\n      if (node.name !== varName) {\n        constNodes[node] = true;\n        return true;\n      }\n\n      return false;\n    },\n    'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {\n      return constTag(constNodes, node.content, varName);\n    },\n    'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {\n      if (node.params.indexOf(varName) === -1) {\n        constNodes[node] = true;\n        return true;\n      }\n\n      return constTag(constNodes, node.expr, varName);\n    },\n    'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {\n      if (node.args.length > 0) {\n        var isConst = constTag(constNodes, node.args[0], varName);\n\n        for (var i = 1; i < node.args.length; ++i) {\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\n        }\n\n        if (isConst) {\n          constNodes[node] = true;\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  /**\r\n   * Applies differentiation rules.\r\n   *\r\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param  {Object} constNodes  Holds the nodes that are constant\r\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\r\n   */\n\n  var _derivative = typed('_derivative', {\n    'ConstantNode, Object': function ConstantNodeObject(node) {\n      return createConstantNode(0);\n    },\n    'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      return createConstantNode(1);\n    },\n    'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {\n      return new ParenthesisNode(_derivative(node.content, constNodes));\n    },\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      return _derivative(node.expr, constNodes);\n    },\n    'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {\n      if (node.args.length !== 1) {\n        funcArgsCheck(node);\n      }\n\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      var arg0 = node.args[0];\n      var arg1;\n      var div = false; // is output a fraction?\n\n      var negative = false; // is output negative?\n\n      var funcDerivative;\n\n      switch (node.name) {\n        case 'cbrt':\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\n          break;\n\n        case 'sqrt':\n        case 'nthRoot':\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\n          if (node.args.length === 1) {\n            div = true;\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\n          } else if (node.args.length === 2) {\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]); // Is a variable?\n\n            constNodes[arg1] = constNodes[node.args[1]];\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\n          }\n\n          break;\n\n        case 'log10':\n          arg1 = createConstantNode(10);\n\n        /* fall through! */\n\n        case 'log':\n          if (!arg1 && node.args.length === 1) {\n            // d/dx(log(x)) = 1 / x\n            funcDerivative = arg0.clone();\n            div = true;\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\n            div = true;\n          } else if (node.args.length === 2) {\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\n          }\n\n          break;\n\n        case 'pow':\n          constNodes[arg1] = constNodes[node.args[1]]; // Pass to pow operator node parser\n\n          return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\n\n        case 'exp':\n          // d/dx(e^x) = e^x\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\n          break;\n\n        case 'sin':\n          // d/dx(sin(x)) = cos(x)\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\n          break;\n\n        case 'cos':\n          // d/dx(cos(x)) = -sin(x)\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\n          break;\n\n        case 'tan':\n          // d/dx(tan(x)) = sec(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'sec':\n          // d/dx(sec(x)) = sec(x)tan(x)\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\n          break;\n\n        case 'csc':\n          // d/dx(csc(x)) = -csc(x)cot(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\n          break;\n\n        case 'cot':\n          // d/dx(cot(x)) = -csc(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'asin':\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n\n        case 'acos':\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n\n        case 'atan':\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\n          div = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n\n        case 'asec':\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acsc':\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acot':\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n\n        case 'sinh':\n          // d/dx(sinh(x)) = cosh(x)\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\n          break;\n\n        case 'cosh':\n          // d/dx(cosh(x)) = sinh(x)\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\n          break;\n\n        case 'tanh':\n          // d/dx(tanh(x)) = sech(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'sech':\n          // d/dx(sech(x)) = -sech(x)tanh(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\n          break;\n\n        case 'csch':\n          // d/dx(csch(x)) = -csch(x)coth(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\n          break;\n\n        case 'coth':\n          // d/dx(coth(x)) = -csch(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\n          break;\n\n        case 'asinh':\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n\n        case 'acosh':\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n\n        case 'atanh':\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\n          div = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n\n        case 'asech':\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\n          break;\n\n        case 'acsch':\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n\n        case 'acoth':\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n\n        case 'abs':\n          // d/dx(abs(x)) = abs(x)/x\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\n          break;\n\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\n\n        default:\n          throw new Error('Function \"' + node.name + '\" is not supported by derivative, or a wrong number of arguments is passed');\n      }\n\n      var op, func;\n\n      if (div) {\n        op = '/';\n        func = 'divide';\n      } else {\n        op = '*';\n        func = 'multiply';\n      }\n      /* Apply chain rule to all functions:\r\n         F(x)  = f(g(x))\r\n         F'(x) = g'(x)*f'(g(x)) */\n\n\n      var chainDerivative = _derivative(arg0, constNodes);\n\n      if (negative) {\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\n      }\n\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\n    },\n    'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n\n      if (node.op === '+') {\n        // d/dx(sum(f(x)) = sum(f'(x))\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\n          return _derivative(arg, constNodes);\n        }));\n      }\n\n      if (node.op === '-') {\n        // d/dx(+/-f(x)) = +/-f'(x)\n        if (node.isUnary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\n        } // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\n\n\n        if (node.isBinary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\n        }\n      }\n\n      if (node.op === '*') {\n        // d/dx(c*f(x)) = c*f'(x)\n        var constantTerms = node.args.filter(function (arg) {\n          return constNodes[arg] !== undefined;\n        });\n\n        if (constantTerms.length > 0) {\n          var nonConstantTerms = node.args.filter(function (arg) {\n            return constNodes[arg] === undefined;\n          });\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\n          return new OperatorNode('*', 'multiply', newArgs);\n        } // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\n\n\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\n          }));\n        }));\n      }\n\n      if (node.op === '/' && node.isBinary()) {\n        var arg0 = node.args[0];\n        var arg1 = node.args[1]; // d/dx(f(x) / c) = f'(x) / c\n\n        if (constNodes[arg1] !== undefined) {\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\n        } // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\n\n\n        if (constNodes[arg0] !== undefined) {\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\n        } // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\n\n\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\n      }\n\n      if (node.op === '^' && node.isBinary()) {\n        var _arg = node.args[0];\n        var _arg2 = node.args[1];\n\n        if (constNodes[_arg] !== undefined) {\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\n          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\n            return createConstantNode(0);\n          } // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\n\n\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\n        }\n\n        if (constNodes[_arg2] !== undefined) {\n          if (isConstantNode(_arg2)) {\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\n            if (isZero(_arg2.value)) {\n              return createConstantNode(0);\n            } // Ignore exponent; f(x)^1 = f(x)\n\n\n            if (equal(_arg2.value, 1)) {\n              return _derivative(_arg, constNodes);\n            }\n          } // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\n\n\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\n        } // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\n\n\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\n      }\n\n      throw new Error('Operator \"' + node.op + '\" is not supported by derivative, or a wrong number of arguments is passed');\n    }\n  });\n  /**\r\n   * Ensures the number of arguments for a function are correct,\r\n   * and will throw an error otherwise.\r\n   *\r\n   * @param {FunctionNode} node\r\n   */\n\n\n  function funcArgsCheck(node) {\n    // TODO add min, max etc\n    if ((node.name === 'log' || node.name === 'nthRoot' || node.name === 'pow') && node.args.length === 2) {\n      return;\n    } // There should be an incorrect number of arguments if we reach here\n    // Change all args to constants to avoid unidentified\n    // symbol error when compiling function\n\n\n    for (var i = 0; i < node.args.length; ++i) {\n      node.args[i] = createConstantNode(0);\n    }\n\n    node.compile().evaluate();\n    throw new Error('Expected TypeError, but none found');\n  }\n  /**\r\n   * Helper function to create a constant node with a specific type\r\n   * (number, BigNumber, Fraction)\r\n   * @param {number} value\r\n   * @param {string} [valueType]\r\n   * @return {ConstantNode}\r\n   */\n\n\n  function createConstantNode(value, valueType) {\n    return new ConstantNode(numeric(value, valueType || config.number));\n  }\n\n  return derivative;\n});","map":{"version":3,"sources":["C:/Users/first/Desktop/numer/Numerpj/node_modules/mathjs/lib/esm/function/algebra/derivative.js"],"names":["isConstantNode","typeOf","factory","name","dependencies","createDerivative","_ref","typed","config","parse","simplify","equal","isZero","numeric","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode","derivative","NodeSymbolNodeObject","expr","variable","options","constNodes","constTag","res","_derivative","NodeSymbolNode","stringSymbolNode","stringSymbolNodeObject","stringString","stringStringObject","NodeString","NodeStringObject","_simplify","toTex","deriv","_derivTex","apply","args","x","value","toString","NodeConstantNode","Error","NodeSymbolNodeConstantNode","order","stringStringNumber","d","concat","ObjectConstantNodeString","node","ObjectSymbolNodeString","varName","ObjectParenthesisNodeString","content","ObjectFunctionAssignmentNodeString","params","indexOf","ObjectFunctionNodeOperatorNodeString","length","isConst","i","ConstantNodeObject","createConstantNode","SymbolNodeObject","undefined","ParenthesisNodeObject","FunctionAssignmentNodeObject","FunctionNodeObject","funcArgsCheck","arg0","arg1","div","negative","funcDerivative","clone","op","func","chainDerivative","OperatorNodeObject","fn","map","arg","isUnary","isBinary","constantTerms","filter","nonConstantTerms","nonConstantNode","newArgs","argOuter","argInner","_arg","_arg2","powMinusOne","compile","evaluate","valueType","number"],"mappings":"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","sourcesContent":["import { isConstantNode, typeOf } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'derivative';\r\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\r\nexport var createDerivative = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    typed,\r\n    config,\r\n    parse,\r\n    simplify,\r\n    equal,\r\n    isZero,\r\n    numeric,\r\n    ConstantNode,\r\n    FunctionNode,\r\n    OperatorNode,\r\n    ParenthesisNode,\r\n    SymbolNode\r\n  } = _ref;\r\n\r\n  /**\r\n   * Takes the derivative of an expression expressed in parser Nodes.\r\n   * The derivative will be taken over the supplied variable in the\r\n   * second parameter. If there are multiple variables in the expression,\r\n   * it will return a partial derivative.\r\n   *\r\n   * This uses rules of differentiation which can be found here:\r\n   *\r\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     derivative(expr, variable)\r\n   *     derivative(expr, variable, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.derivative('x^2', 'x')                     // Node {2 * x}\r\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node {2 * 1 * x ^ (2 - 1)\r\n   *     math.derivative('sin(2x)', 'x'))                // Node {2 * cos(2 * x)}\r\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\r\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\r\n   *     const f = math.parse('x^2')\r\n   *     const x = math.parse('x')\r\n   *     math.derivative(f, x)                           // Node {2 * x}\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, parse, evaluate\r\n   *\r\n   * @param  {Node | string} expr           The expression to differentiate\r\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\r\n   * @param  {{simplify: boolean}} [options]\r\n   *                         There is one option available, `simplify`, which\r\n   *                         is true by default. When false, output will not\r\n   *                         be simplified.\r\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\r\n   */\r\n  var derivative = typed('derivative', {\r\n    'Node, SymbolNode, Object': function NodeSymbolNodeObject(expr, variable, options) {\r\n      var constNodes = {};\r\n      constTag(constNodes, expr, variable.name);\r\n\r\n      var res = _derivative(expr, constNodes);\r\n\r\n      return options.simplify ? simplify(res) : res;\r\n    },\r\n    'Node, SymbolNode': function NodeSymbolNode(expr, variable) {\r\n      return this(expr, variable, {\r\n        simplify: true\r\n      });\r\n    },\r\n    'string, SymbolNode': function stringSymbolNode(expr, variable) {\r\n      return this(parse(expr), variable);\r\n    },\r\n    'string, SymbolNode, Object': function stringSymbolNodeObject(expr, variable, options) {\r\n      return this(parse(expr), variable, options);\r\n    },\r\n    'string, string': function stringString(expr, variable) {\r\n      return this(parse(expr), parse(variable));\r\n    },\r\n    'string, string, Object': function stringStringObject(expr, variable, options) {\r\n      return this(parse(expr), parse(variable), options);\r\n    },\r\n    'Node, string': function NodeString(expr, variable) {\r\n      return this(expr, parse(variable));\r\n    },\r\n    'Node, string, Object': function NodeStringObject(expr, variable, options) {\r\n      return this(expr, parse(variable), options);\r\n    } // TODO: replace the 8 signatures above with 4 as soon as typed-function supports optional arguments\r\n\r\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\r\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\r\n      let res = expr\r\n      for (let i = 0; i < order; i++) {\r\n        let constNodes = {}\r\n        constTag(constNodes, expr, variable.name)\r\n        res = _derivative(res, constNodes)\r\n      }\r\n      return res\r\n    }\r\n    */\r\n\r\n  });\r\n  derivative._simplify = true;\r\n\r\n  derivative.toTex = function (deriv) {\r\n    return _derivTex.apply(null, deriv.args);\r\n  }; // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\r\n  // NOTE: the optional \"order\" parameter here is currently unused\r\n\r\n\r\n  var _derivTex = typed('_derivTex', {\r\n    'Node, SymbolNode': function NodeSymbolNode(expr, x) {\r\n      if (isConstantNode(expr) && typeOf(expr.value) === 'string') {\r\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\r\n      } else {\r\n        return _derivTex(expr.toString(), x.toString(), 1);\r\n      }\r\n    },\r\n    'Node, ConstantNode': function NodeConstantNode(expr, x) {\r\n      if (typeOf(x.value) === 'string') {\r\n        return _derivTex(expr, parse(x.value));\r\n      } else {\r\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\r\n      }\r\n    },\r\n    'Node, SymbolNode, ConstantNode': function NodeSymbolNodeConstantNode(expr, x, order) {\r\n      return _derivTex(expr.toString(), x.name, order.value);\r\n    },\r\n    'string, string, number': function stringStringNumber(expr, x, order) {\r\n      var d;\r\n\r\n      if (order === 1) {\r\n        d = '{d\\\\over d' + x + '}';\r\n      } else {\r\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\r\n      }\r\n\r\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\r\n    }\r\n  });\r\n  /**\r\n   * Does a depth-first search on the expression tree to identify what Nodes\r\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\r\n   * constNodes. Classification is done as follows:\r\n   *\r\n   *   1. ConstantNodes are constants.\r\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\r\n   *      in the subtree it is not constant.\r\n   *\r\n   * @param  {Object} constNodes  Holds the nodes that are constant\r\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param  {string} varName     Variable that we are differentiating\r\n   * @return {boolean}  if node is constant\r\n   */\r\n  // TODO: can we rewrite constTag into a pure function?\r\n\r\n\r\n  var constTag = typed('constTag', {\r\n    'Object, ConstantNode, string': function ObjectConstantNodeString(constNodes, node) {\r\n      constNodes[node] = true;\r\n      return true;\r\n    },\r\n    'Object, SymbolNode, string': function ObjectSymbolNodeString(constNodes, node, varName) {\r\n      // Treat other variables like constants. For reasoning, see:\r\n      //   https://en.wikipedia.org/wiki/Partial_derivative\r\n      if (node.name !== varName) {\r\n        constNodes[node] = true;\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    },\r\n    'Object, ParenthesisNode, string': function ObjectParenthesisNodeString(constNodes, node, varName) {\r\n      return constTag(constNodes, node.content, varName);\r\n    },\r\n    'Object, FunctionAssignmentNode, string': function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {\r\n      if (node.params.indexOf(varName) === -1) {\r\n        constNodes[node] = true;\r\n        return true;\r\n      }\r\n\r\n      return constTag(constNodes, node.expr, varName);\r\n    },\r\n    'Object, FunctionNode | OperatorNode, string': function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {\r\n      if (node.args.length > 0) {\r\n        var isConst = constTag(constNodes, node.args[0], varName);\r\n\r\n        for (var i = 1; i < node.args.length; ++i) {\r\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\r\n        }\r\n\r\n        if (isConst) {\r\n          constNodes[node] = true;\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n  });\r\n  /**\r\n   * Applies differentiation rules.\r\n   *\r\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param  {Object} constNodes  Holds the nodes that are constant\r\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\r\n   */\r\n\r\n  var _derivative = typed('_derivative', {\r\n    'ConstantNode, Object': function ConstantNodeObject(node) {\r\n      return createConstantNode(0);\r\n    },\r\n    'SymbolNode, Object': function SymbolNodeObject(node, constNodes) {\r\n      if (constNodes[node] !== undefined) {\r\n        return createConstantNode(0);\r\n      }\r\n\r\n      return createConstantNode(1);\r\n    },\r\n    'ParenthesisNode, Object': function ParenthesisNodeObject(node, constNodes) {\r\n      return new ParenthesisNode(_derivative(node.content, constNodes));\r\n    },\r\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNodeObject(node, constNodes) {\r\n      if (constNodes[node] !== undefined) {\r\n        return createConstantNode(0);\r\n      }\r\n\r\n      return _derivative(node.expr, constNodes);\r\n    },\r\n    'FunctionNode, Object': function FunctionNodeObject(node, constNodes) {\r\n      if (node.args.length !== 1) {\r\n        funcArgsCheck(node);\r\n      }\r\n\r\n      if (constNodes[node] !== undefined) {\r\n        return createConstantNode(0);\r\n      }\r\n\r\n      var arg0 = node.args[0];\r\n      var arg1;\r\n      var div = false; // is output a fraction?\r\n\r\n      var negative = false; // is output negative?\r\n\r\n      var funcDerivative;\r\n\r\n      switch (node.name) {\r\n        case 'cbrt':\r\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\r\n          div = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\r\n          break;\r\n\r\n        case 'sqrt':\r\n        case 'nthRoot':\r\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\r\n          if (node.args.length === 1) {\r\n            div = true;\r\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\r\n          } else if (node.args.length === 2) {\r\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\r\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]); // Is a variable?\r\n\r\n            constNodes[arg1] = constNodes[node.args[1]];\r\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\r\n          }\r\n\r\n          break;\r\n\r\n        case 'log10':\r\n          arg1 = createConstantNode(10);\r\n\r\n        /* fall through! */\r\n\r\n        case 'log':\r\n          if (!arg1 && node.args.length === 1) {\r\n            // d/dx(log(x)) = 1 / x\r\n            funcDerivative = arg0.clone();\r\n            div = true;\r\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\r\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\r\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\r\n            div = true;\r\n          } else if (node.args.length === 2) {\r\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\r\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\r\n          }\r\n\r\n          break;\r\n\r\n        case 'pow':\r\n          constNodes[arg1] = constNodes[node.args[1]]; // Pass to pow operator node parser\r\n\r\n          return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\r\n\r\n        case 'exp':\r\n          // d/dx(e^x) = e^x\r\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\r\n          break;\r\n\r\n        case 'sin':\r\n          // d/dx(sin(x)) = cos(x)\r\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\r\n          break;\r\n\r\n        case 'cos':\r\n          // d/dx(cos(x)) = -sin(x)\r\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\r\n          break;\r\n\r\n        case 'tan':\r\n          // d/dx(tan(x)) = sec(x)^2\r\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\r\n          break;\r\n\r\n        case 'sec':\r\n          // d/dx(sec(x)) = sec(x)tan(x)\r\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\r\n          break;\r\n\r\n        case 'csc':\r\n          // d/dx(csc(x)) = -csc(x)cot(x)\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\r\n          break;\r\n\r\n        case 'cot':\r\n          // d/dx(cot(x)) = -csc(x)^2\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\r\n          break;\r\n\r\n        case 'asin':\r\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\r\n          div = true;\r\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\r\n          break;\r\n\r\n        case 'acos':\r\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\r\n          div = true;\r\n          negative = true;\r\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\r\n          break;\r\n\r\n        case 'atan':\r\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\r\n          div = true;\r\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\r\n          break;\r\n\r\n        case 'asec':\r\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\r\n          div = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\r\n          break;\r\n\r\n        case 'acsc':\r\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\r\n          div = true;\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\r\n          break;\r\n\r\n        case 'acot':\r\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\r\n          div = true;\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\r\n          break;\r\n\r\n        case 'sinh':\r\n          // d/dx(sinh(x)) = cosh(x)\r\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\r\n          break;\r\n\r\n        case 'cosh':\r\n          // d/dx(cosh(x)) = sinh(x)\r\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\r\n          break;\r\n\r\n        case 'tanh':\r\n          // d/dx(tanh(x)) = sech(x)^2\r\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\r\n          break;\r\n\r\n        case 'sech':\r\n          // d/dx(sech(x)) = -sech(x)tanh(x)\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\r\n          break;\r\n\r\n        case 'csch':\r\n          // d/dx(csch(x)) = -csch(x)coth(x)\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\r\n          break;\r\n\r\n        case 'coth':\r\n          // d/dx(coth(x)) = -csch(x)^2\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\r\n          break;\r\n\r\n        case 'asinh':\r\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\r\n          div = true;\r\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\r\n          break;\r\n\r\n        case 'acosh':\r\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\r\n          div = true;\r\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\r\n          break;\r\n\r\n        case 'atanh':\r\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\r\n          div = true;\r\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\r\n          break;\r\n\r\n        case 'asech':\r\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\r\n          div = true;\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\r\n          break;\r\n\r\n        case 'acsch':\r\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\r\n          div = true;\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\r\n          break;\r\n\r\n        case 'acoth':\r\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\r\n          div = true;\r\n          negative = true;\r\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\r\n          break;\r\n\r\n        case 'abs':\r\n          // d/dx(abs(x)) = abs(x)/x\r\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\r\n          break;\r\n\r\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\r\n\r\n        default:\r\n          throw new Error('Function \"' + node.name + '\" is not supported by derivative, or a wrong number of arguments is passed');\r\n      }\r\n\r\n      var op, func;\r\n\r\n      if (div) {\r\n        op = '/';\r\n        func = 'divide';\r\n      } else {\r\n        op = '*';\r\n        func = 'multiply';\r\n      }\r\n      /* Apply chain rule to all functions:\r\n         F(x)  = f(g(x))\r\n         F'(x) = g'(x)*f'(g(x)) */\r\n\r\n\r\n      var chainDerivative = _derivative(arg0, constNodes);\r\n\r\n      if (negative) {\r\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\r\n      }\r\n\r\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\r\n    },\r\n    'OperatorNode, Object': function OperatorNodeObject(node, constNodes) {\r\n      if (constNodes[node] !== undefined) {\r\n        return createConstantNode(0);\r\n      }\r\n\r\n      if (node.op === '+') {\r\n        // d/dx(sum(f(x)) = sum(f'(x))\r\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\r\n          return _derivative(arg, constNodes);\r\n        }));\r\n      }\r\n\r\n      if (node.op === '-') {\r\n        // d/dx(+/-f(x)) = +/-f'(x)\r\n        if (node.isUnary()) {\r\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\r\n        } // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\r\n\r\n\r\n        if (node.isBinary()) {\r\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\r\n        }\r\n      }\r\n\r\n      if (node.op === '*') {\r\n        // d/dx(c*f(x)) = c*f'(x)\r\n        var constantTerms = node.args.filter(function (arg) {\r\n          return constNodes[arg] !== undefined;\r\n        });\r\n\r\n        if (constantTerms.length > 0) {\r\n          var nonConstantTerms = node.args.filter(function (arg) {\r\n            return constNodes[arg] === undefined;\r\n          });\r\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\r\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\r\n          return new OperatorNode('*', 'multiply', newArgs);\r\n        } // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\r\n\r\n\r\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\r\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\r\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\r\n          }));\r\n        }));\r\n      }\r\n\r\n      if (node.op === '/' && node.isBinary()) {\r\n        var arg0 = node.args[0];\r\n        var arg1 = node.args[1]; // d/dx(f(x) / c) = f'(x) / c\r\n\r\n        if (constNodes[arg1] !== undefined) {\r\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\r\n        } // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\r\n\r\n\r\n        if (constNodes[arg0] !== undefined) {\r\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\r\n        } // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\r\n\r\n\r\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\r\n      }\r\n\r\n      if (node.op === '^' && node.isBinary()) {\r\n        var _arg = node.args[0];\r\n        var _arg2 = node.args[1];\r\n\r\n        if (constNodes[_arg] !== undefined) {\r\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\r\n          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\r\n            return createConstantNode(0);\r\n          } // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\r\n\r\n\r\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\r\n        }\r\n\r\n        if (constNodes[_arg2] !== undefined) {\r\n          if (isConstantNode(_arg2)) {\r\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\r\n            if (isZero(_arg2.value)) {\r\n              return createConstantNode(0);\r\n            } // Ignore exponent; f(x)^1 = f(x)\r\n\r\n\r\n            if (equal(_arg2.value, 1)) {\r\n              return _derivative(_arg, constNodes);\r\n            }\r\n          } // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\r\n\r\n\r\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\r\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\r\n        } // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\r\n\r\n\r\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\r\n      }\r\n\r\n      throw new Error('Operator \"' + node.op + '\" is not supported by derivative, or a wrong number of arguments is passed');\r\n    }\r\n  });\r\n  /**\r\n   * Ensures the number of arguments for a function are correct,\r\n   * and will throw an error otherwise.\r\n   *\r\n   * @param {FunctionNode} node\r\n   */\r\n\r\n\r\n  function funcArgsCheck(node) {\r\n    // TODO add min, max etc\r\n    if ((node.name === 'log' || node.name === 'nthRoot' || node.name === 'pow') && node.args.length === 2) {\r\n      return;\r\n    } // There should be an incorrect number of arguments if we reach here\r\n    // Change all args to constants to avoid unidentified\r\n    // symbol error when compiling function\r\n\r\n\r\n    for (var i = 0; i < node.args.length; ++i) {\r\n      node.args[i] = createConstantNode(0);\r\n    }\r\n\r\n    node.compile().evaluate();\r\n    throw new Error('Expected TypeError, but none found');\r\n  }\r\n  /**\r\n   * Helper function to create a constant node with a specific type\r\n   * (number, BigNumber, Fraction)\r\n   * @param {number} value\r\n   * @param {string} [valueType]\r\n   * @return {ConstantNode}\r\n   */\r\n\r\n\r\n  function createConstantNode(value, valueType) {\r\n    return new ConstantNode(numeric(value, valueType || config.number));\r\n  }\r\n\r\n  return derivative;\r\n});"]},"metadata":{},"sourceType":"module"}