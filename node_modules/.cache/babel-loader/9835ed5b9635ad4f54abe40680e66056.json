{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { forEach, map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'BlockNode';\nvar dependencies = ['ResultSet', 'Node'];\nexport var createBlockNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    ResultSet,\n    Node\n  } = _ref;\n  /**\r\n   * @constructor BlockNode\r\n   * @extends {Node}\r\n   * Holds a set with blocks\r\n   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\r\n   *            An array with blocks, where a block is constructed as an Object\r\n   *            with properties block, which is a Node, and visible, which is\r\n   *            a boolean. The property visible is optional and is true by default\r\n   */\n\n  function BlockNode(blocks) {\n    if (!(this instanceof BlockNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input, copy blocks\n\n\n    if (!Array.isArray(blocks)) throw new Error('Array expected');\n    this.blocks = blocks.map(function (block) {\n      var node = block && block.node;\n      var visible = block && block.visible !== undefined ? block.visible : true;\n      if (!isNode(node)) throw new TypeError('Property \"node\" must be a Node');\n      if (typeof visible !== 'boolean') throw new TypeError('Property \"visible\" must be a boolean');\n      return {\n        node: node,\n        visible: visible\n      };\n    });\n  }\n\n  BlockNode.prototype = new Node();\n  BlockNode.prototype.type = 'BlockNode';\n  BlockNode.prototype.isBlockNode = true;\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\n\n  BlockNode.prototype._compile = function (math, argNames) {\n    var evalBlocks = map(this.blocks, function (block) {\n      return {\n        evaluate: block.node._compile(math, argNames),\n        visible: block.visible\n      };\n    });\n    return function evalBlockNodes(scope, args, context) {\n      var results = [];\n      forEach(evalBlocks, function evalBlockNode(block) {\n        var result = block.evaluate(scope, args, context);\n\n        if (block.visible) {\n          results.push(result);\n        }\n      });\n      return new ResultSet(results);\n    };\n  };\n  /**\r\n   * Execute a callback for each of the child blocks of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\n\n\n  BlockNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.blocks.length; i++) {\n      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n    }\n  };\n  /**\r\n   * Create a new BlockNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {BlockNode} Returns a transformed copy of the node\r\n   */\n\n\n  BlockNode.prototype.map = function (callback) {\n    var blocks = [];\n\n    for (var i = 0; i < this.blocks.length; i++) {\n      var block = this.blocks[i];\n\n      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n\n      blocks[i] = {\n        node: node,\n        visible: block.visible\n      };\n    }\n\n    return new BlockNode(blocks);\n  };\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {BlockNode}\r\n   */\n\n\n  BlockNode.prototype.clone = function () {\n    var blocks = this.blocks.map(function (block) {\n      return {\n        node: block.node,\n        visible: block.visible\n      };\n    });\n    return new BlockNode(blocks);\n  };\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  BlockNode.prototype._toString = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toString(options) + (param.visible ? '' : ';');\n    }).join('\\n');\n  };\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\n\n\n  BlockNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'BlockNode',\n      blocks: this.blocks\n    };\n  };\n  /**\r\n   * Instantiate an BlockNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\r\n   *                       where mathjs is optional\r\n   * @returns {BlockNode}\r\n   */\n\n\n  BlockNode.fromJSON = function (json) {\n    return new BlockNode(json.blocks);\n  };\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\n\n\n  BlockNode.prototype.toHTML = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n    }).join('<span class=\"math-separator\"><br /></span>');\n  };\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\n\n\n  BlockNode.prototype._toTex = function (options) {\n    return this.blocks.map(function (param) {\n      return param.node.toTex(options) + (param.visible ? '' : ';');\n    }).join('\\\\;\\\\;\\n');\n  };\n\n  return BlockNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/first/Desktop/numer/Numerpj/node_modules/mathjs/lib/esm/expression/node/BlockNode.js"],"names":["isNode","forEach","map","factory","name","dependencies","createBlockNode","_ref","ResultSet","Node","BlockNode","blocks","SyntaxError","Array","isArray","Error","block","node","visible","undefined","TypeError","prototype","type","isBlockNode","_compile","math","argNames","evalBlocks","evaluate","evalBlockNodes","scope","args","context","results","evalBlockNode","result","push","callback","i","length","_ifNode","clone","_toString","options","param","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is.js';\r\nimport { forEach, map } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'BlockNode';\r\nvar dependencies = ['ResultSet', 'Node'];\r\nexport var createBlockNode = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    ResultSet,\r\n    Node\r\n  } = _ref;\r\n\r\n  /**\r\n   * @constructor BlockNode\r\n   * @extends {Node}\r\n   * Holds a set with blocks\r\n   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\r\n   *            An array with blocks, where a block is constructed as an Object\r\n   *            with properties block, which is a Node, and visible, which is\r\n   *            a boolean. The property visible is optional and is true by default\r\n   */\r\n  function BlockNode(blocks) {\r\n    if (!(this instanceof BlockNode)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    } // validate input, copy blocks\r\n\r\n\r\n    if (!Array.isArray(blocks)) throw new Error('Array expected');\r\n    this.blocks = blocks.map(function (block) {\r\n      var node = block && block.node;\r\n      var visible = block && block.visible !== undefined ? block.visible : true;\r\n      if (!isNode(node)) throw new TypeError('Property \"node\" must be a Node');\r\n      if (typeof visible !== 'boolean') throw new TypeError('Property \"visible\" must be a boolean');\r\n      return {\r\n        node: node,\r\n        visible: visible\r\n      };\r\n    });\r\n  }\r\n\r\n  BlockNode.prototype = new Node();\r\n  BlockNode.prototype.type = 'BlockNode';\r\n  BlockNode.prototype.isBlockNode = true;\r\n  /**\r\n   * Compile a node into a JavaScript function.\r\n   * This basically pre-calculates as much as possible and only leaves open\r\n   * calculations which depend on a dynamic scope with variables.\r\n   * @param {Object} math     Math.js namespace with functions and constants.\r\n   * @param {Object} argNames An object with argument names as key and `true`\r\n   *                          as value. Used in the SymbolNode to optimize\r\n   *                          for arguments from user assigned functions\r\n   *                          (see FunctionAssignmentNode) or special symbols\r\n   *                          like `end` (see IndexNode).\r\n   * @return {function} Returns a function which can be called like:\r\n   *                        evalNode(scope: Object, args: Object, context: *)\r\n   */\r\n\r\n  BlockNode.prototype._compile = function (math, argNames) {\r\n    var evalBlocks = map(this.blocks, function (block) {\r\n      return {\r\n        evaluate: block.node._compile(math, argNames),\r\n        visible: block.visible\r\n      };\r\n    });\r\n    return function evalBlockNodes(scope, args, context) {\r\n      var results = [];\r\n      forEach(evalBlocks, function evalBlockNode(block) {\r\n        var result = block.evaluate(scope, args, context);\r\n\r\n        if (block.visible) {\r\n          results.push(result);\r\n        }\r\n      });\r\n      return new ResultSet(results);\r\n    };\r\n  };\r\n  /**\r\n   * Execute a callback for each of the child blocks of this node\r\n   * @param {function(child: Node, path: string, parent: Node)} callback\r\n   */\r\n\r\n\r\n  BlockNode.prototype.forEach = function (callback) {\r\n    for (var i = 0; i < this.blocks.length; i++) {\r\n      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\r\n    }\r\n  };\r\n  /**\r\n   * Create a new BlockNode having it's childs be the results of calling\r\n   * the provided callback function for each of the childs of the original node.\r\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n   * @returns {BlockNode} Returns a transformed copy of the node\r\n   */\r\n\r\n\r\n  BlockNode.prototype.map = function (callback) {\r\n    var blocks = [];\r\n\r\n    for (var i = 0; i < this.blocks.length; i++) {\r\n      var block = this.blocks[i];\r\n\r\n      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\r\n\r\n      blocks[i] = {\r\n        node: node,\r\n        visible: block.visible\r\n      };\r\n    }\r\n\r\n    return new BlockNode(blocks);\r\n  };\r\n  /**\r\n   * Create a clone of this node, a shallow copy\r\n   * @return {BlockNode}\r\n   */\r\n\r\n\r\n  BlockNode.prototype.clone = function () {\r\n    var blocks = this.blocks.map(function (block) {\r\n      return {\r\n        node: block.node,\r\n        visible: block.visible\r\n      };\r\n    });\r\n    return new BlockNode(blocks);\r\n  };\r\n  /**\r\n   * Get string representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  BlockNode.prototype._toString = function (options) {\r\n    return this.blocks.map(function (param) {\r\n      return param.node.toString(options) + (param.visible ? '' : ';');\r\n    }).join('\\n');\r\n  };\r\n  /**\r\n   * Get a JSON representation of the node\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  BlockNode.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'BlockNode',\r\n      blocks: this.blocks\r\n    };\r\n  };\r\n  /**\r\n   * Instantiate an BlockNode from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\r\n   *                       where mathjs is optional\r\n   * @returns {BlockNode}\r\n   */\r\n\r\n\r\n  BlockNode.fromJSON = function (json) {\r\n    return new BlockNode(json.blocks);\r\n  };\r\n  /**\r\n   * Get HTML representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   * @override\r\n   */\r\n\r\n\r\n  BlockNode.prototype.toHTML = function (options) {\r\n    return this.blocks.map(function (param) {\r\n      return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\r\n    }).join('<span class=\"math-separator\"><br /></span>');\r\n  };\r\n  /**\r\n   * Get LaTeX representation\r\n   * @param {Object} options\r\n   * @return {string} str\r\n   */\r\n\r\n\r\n  BlockNode.prototype._toTex = function (options) {\r\n    return this.blocks.map(function (param) {\r\n      return param.node.toTex(options) + (param.visible ? '' : ';');\r\n    }).join('\\\\;\\\\;\\n');\r\n  };\r\n\r\n  return BlockNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}