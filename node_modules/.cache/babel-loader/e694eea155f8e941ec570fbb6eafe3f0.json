{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply,\n    unaryMinus,\n    lup\n  } = _ref;\n  /**\r\n   * Calculate the determinant of a matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.det(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.det([[1, 2], [3, 4]]) // returns -2\r\n   *\r\n   *    const A = [\r\n   *      [-2, 2, 3],\r\n   *      [-1, 1, 3],\r\n   *      [2, 0, -1]\r\n   *    ]\r\n   *    math.det(A) // returns 6\r\n   *\r\n   * See also:\r\n   *\r\n   *    inv\r\n   *\r\n   * @param {Array | Matrix} x  A matrix\r\n   * @return {number} The determinant of `x`\r\n   */\n\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n\n        case 2:\n          {\n            // two dimensional array\n            var rows = size[0];\n            var cols = size[1];\n\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n  /**\r\n   * Calculate the determinant of a matrix\r\n   * @param {Array[]} matrix  A square, two dimensional matrix\r\n   * @param {number} rows     Number of rows of the matrix (zero-based)\r\n   * @param {number} cols     Number of columns of the matrix (zero-based)\r\n   * @returns {number} det\r\n   * @private\r\n   */\n\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Compute the LU decomposition\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\n\n      var det = decomp.U[0][0];\n\n      for (var _i = 1; _i < rows; _i++) {\n        det = multiply(det, decomp.U[_i][_i]);\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\n\n\n      var evenCycles = 0;\n      var i = 0;\n      var visited = [];\n\n      while (true) {\n        while (visited[i]) {\n          i++;\n        }\n\n        if (i >= rows) break;\n        var j = i;\n        var cycleLen = 0;\n\n        while (!visited[decomp.p[j]]) {\n          visited[decomp.p[j]] = true;\n          j = decomp.p[j];\n          cycleLen++;\n        }\n\n        if (cycleLen % 2 === 0) {\n          evenCycles++;\n        }\n      }\n\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/big49/Desktop/clone2/Numerpj/node_modules/mathjs/lib/esm/function/matrix/det.js"],"names":["isMatrix","clone","format","factory","name","dependencies","createDet","_ref","typed","matrix","subtract","multiply","unaryMinus","lup","any","x","det","size","Array","isArray","length","valueOf","RangeError","rows","cols","_det","decomp","U","_i","evenCycles","i","visited","j","cycleLen","p"],"mappings":"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","sourcesContent":["import { isMatrix } from '../../utils/is.js';\r\nimport { clone } from '../../utils/object.js';\r\nimport { format } from '../../utils/string.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'det';\r\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply', 'unaryMinus', 'lup'];\r\nexport var createDet = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    subtract,\r\n    multiply,\r\n    unaryMinus,\r\n    lup\r\n  } = _ref;\r\n\r\n  /**\r\n   * Calculate the determinant of a matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.det(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.det([[1, 2], [3, 4]]) // returns -2\r\n   *\r\n   *    const A = [\r\n   *      [-2, 2, 3],\r\n   *      [-1, 1, 3],\r\n   *      [2, 0, -1]\r\n   *    ]\r\n   *    math.det(A) // returns 6\r\n   *\r\n   * See also:\r\n   *\r\n   *    inv\r\n   *\r\n   * @param {Array | Matrix} x  A matrix\r\n   * @return {number} The determinant of `x`\r\n   */\r\n  return typed(name, {\r\n    any: function any(x) {\r\n      return clone(x);\r\n    },\r\n    'Array | Matrix': function det(x) {\r\n      var size;\r\n\r\n      if (isMatrix(x)) {\r\n        size = x.size();\r\n      } else if (Array.isArray(x)) {\r\n        x = matrix(x);\r\n        size = x.size();\r\n      } else {\r\n        // a scalar\r\n        size = [];\r\n      }\r\n\r\n      switch (size.length) {\r\n        case 0:\r\n          // scalar\r\n          return clone(x);\r\n\r\n        case 1:\r\n          // vector\r\n          if (size[0] === 1) {\r\n            return clone(x.valueOf()[0]);\r\n          } else {\r\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\r\n          }\r\n\r\n        case 2:\r\n          {\r\n            // two dimensional array\r\n            var rows = size[0];\r\n            var cols = size[1];\r\n\r\n            if (rows === cols) {\r\n              return _det(x.clone().valueOf(), rows, cols);\r\n            } else {\r\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\r\n            }\r\n          }\r\n\r\n        default:\r\n          // multi dimensional array\r\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\r\n      }\r\n    }\r\n  });\r\n  /**\r\n   * Calculate the determinant of a matrix\r\n   * @param {Array[]} matrix  A square, two dimensional matrix\r\n   * @param {number} rows     Number of rows of the matrix (zero-based)\r\n   * @param {number} cols     Number of columns of the matrix (zero-based)\r\n   * @returns {number} det\r\n   * @private\r\n   */\r\n\r\n  function _det(matrix, rows, cols) {\r\n    if (rows === 1) {\r\n      // this is a 1 x 1 matrix\r\n      return clone(matrix[0][0]);\r\n    } else if (rows === 2) {\r\n      // this is a 2 x 2 matrix\r\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\r\n      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\r\n    } else {\r\n      // Compute the LU decomposition\r\n      var decomp = lup(matrix); // The determinant is the product of the diagonal entries of U (and those of L, but they are all 1)\r\n\r\n      var det = decomp.U[0][0];\r\n\r\n      for (var _i = 1; _i < rows; _i++) {\r\n        det = multiply(det, decomp.U[_i][_i]);\r\n      } // The determinant will be multiplied by 1 or -1 depending on the parity of the permutation matrix.\r\n      // This can be determined by counting the cycles. This is roughly a linear time algorithm.\r\n\r\n\r\n      var evenCycles = 0;\r\n      var i = 0;\r\n      var visited = [];\r\n\r\n      while (true) {\r\n        while (visited[i]) {\r\n          i++;\r\n        }\r\n\r\n        if (i >= rows) break;\r\n        var j = i;\r\n        var cycleLen = 0;\r\n\r\n        while (!visited[decomp.p[j]]) {\r\n          visited[decomp.p[j]] = true;\r\n          j = decomp.p[j];\r\n          cycleLen++;\r\n        }\r\n\r\n        if (cycleLen % 2 === 0) {\r\n          evenCycles++;\r\n        }\r\n      }\r\n\r\n      return evenCycles % 2 === 0 ? det : unaryMinus(det);\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}