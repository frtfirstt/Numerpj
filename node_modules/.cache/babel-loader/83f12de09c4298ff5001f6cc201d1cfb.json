{"ast":null,"code":"import { isMatrix, isRange } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'Index';\nvar dependencies = ['ImmutableDenseMatrix'];\nexport var createIndexClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    ImmutableDenseMatrix\n  } = _ref;\n  /**\r\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\r\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\r\n   *\r\n   * Usage:\r\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\r\n   *\r\n   * Where each parameter can be any of:\r\n   *     A number\r\n   *     A string (containing a name of an object property)\r\n   *     An instance of Range\r\n   *     An Array with the Set values\r\n   *     A Matrix with the Set values\r\n   *\r\n   * The parameters start, end, and step must be integer numbers.\r\n   *\r\n   * @class Index\r\n   * @Constructor Index\r\n   * @param {...*} ranges\r\n   */\n\n  function Index(ranges) {\n    if (!(this instanceof Index)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this._dimensions = [];\n    this._isScalar = true;\n\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n\n      if (isRange(arg)) {\n        this._dimensions.push(arg);\n\n        this._isScalar = false;\n      } else if (Array.isArray(arg) || isMatrix(arg)) {\n        // create matrix\n        var m = _createImmutableMatrix(arg.valueOf());\n\n        this._dimensions.push(m); // size\n\n\n        var size = m.size(); // scalar\n\n        if (size.length !== 1 || size[0] !== 1) {\n          this._isScalar = false;\n        }\n      } else if (typeof arg === 'number') {\n        this._dimensions.push(_createImmutableMatrix([arg]));\n      } else if (typeof arg === 'string') {\n        // object property (arguments.count should be 1)\n        this._dimensions.push(arg);\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      } // TODO: implement support for wildcard '*'\n\n    }\n  }\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Index.prototype.type = 'Index';\n  Index.prototype.isIndex = true;\n\n  function _createImmutableMatrix(arg) {\n    // loop array elements\n    for (var i = 0, l = arg.length; i < l; i++) {\n      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {\n        throw new TypeError('Index parameters must be positive integer numbers');\n      }\n    } // create matrix\n\n\n    return new ImmutableDenseMatrix(arg);\n  }\n  /**\r\n   * Create a clone of the index\r\n   * @memberof Index\r\n   * @return {Index} clone\r\n   */\n\n\n  Index.prototype.clone = function () {\n    var index = new Index();\n    index._dimensions = clone(this._dimensions);\n    index._isScalar = this._isScalar;\n    return index;\n  };\n  /**\r\n   * Create an index from an array with ranges/numbers\r\n   * @memberof Index\r\n   * @param {Array.<Array | number>} ranges\r\n   * @return {Index} index\r\n   * @private\r\n   */\n\n\n  Index.create = function (ranges) {\n    var index = new Index();\n    Index.apply(index, ranges);\n    return index;\n  };\n  /**\r\n   * Retrieve the size of the index, the number of elements for each dimension.\r\n   * @memberof Index\r\n   * @returns {number[]} size\r\n   */\n\n\n  Index.prototype.size = function () {\n    var size = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var d = this._dimensions[i];\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\n    }\n\n    return size;\n  };\n  /**\r\n   * Get the maximum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} max\r\n   */\n\n\n  Index.prototype.max = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.max();\n    }\n\n    return values;\n  };\n  /**\r\n   * Get the minimum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} min\r\n   */\n\n\n  Index.prototype.min = function () {\n    var values = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.min();\n    }\n\n    return values;\n  };\n  /**\r\n   * Loop over each of the ranges of the index\r\n   * @memberof Index\r\n   * @param {Function} callback   Called for each range with a Range as first\r\n   *                              argument, the dimension as second, and the\r\n   *                              index object as third.\r\n   */\n\n\n  Index.prototype.forEach = function (callback) {\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      callback(this._dimensions[i], i, this);\n    }\n  };\n  /**\r\n   * Retrieve the dimension for the given index\r\n   * @memberof Index\r\n   * @param {Number} dim                  Number of the dimension\r\n   * @returns {Range | null} range\r\n   */\n\n\n  Index.prototype.dimension = function (dim) {\n    return this._dimensions[dim] || null;\n  };\n  /**\r\n   * Test whether this index contains an object property\r\n   * @returns {boolean} Returns true if the index is an object property\r\n   */\n\n\n  Index.prototype.isObjectProperty = function () {\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\n  };\n  /**\r\n   * Returns the object property name when the Index holds a single object property,\r\n   * else returns null\r\n   * @returns {string | null}\r\n   */\n\n\n  Index.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this._dimensions[0] : null;\n  };\n  /**\r\n   * Test whether this index contains only a single value.\r\n   *\r\n   * This is the case when the index is created with only scalar values as ranges,\r\n   * not for ranges resolving into a single value.\r\n   * @memberof Index\r\n   * @return {boolean} isScalar\r\n   */\n\n\n  Index.prototype.isScalar = function () {\n    return this._isScalar;\n  };\n  /**\r\n   * Expand the Index into an array.\r\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\n\n\n  Index.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\n    }\n\n    return array;\n  };\n  /**\r\n   * Get the primitive value of the Index, a two dimensional array.\r\n   * Equivalent to Index.toArray().\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\n\n\n  Index.prototype.valueOf = Index.prototype.toArray;\n  /**\r\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\r\n   * @memberof Index\r\n   * @returns {String} str\r\n   */\n\n  Index.prototype.toString = function () {\n    var strings = [];\n\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n\n      if (typeof dimension === 'string') {\n        strings.push(JSON.stringify(dimension));\n      } else {\n        strings.push(dimension.toString());\n      }\n    }\n\n    return '[' + strings.join(', ') + ']';\n  };\n  /**\r\n   * Get a JSON representation of the Index\r\n   * @memberof Index\r\n   * @returns {Object} Returns a JSON object structured as:\r\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   */\n\n\n  Index.prototype.toJSON = function () {\n    return {\n      mathjs: 'Index',\n      dimensions: this._dimensions\n    };\n  };\n  /**\r\n   * Instantiate an Index from a JSON object\r\n   * @memberof Index\r\n   * @param {Object} json A JSON object structured as:\r\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   * @return {Index}\r\n   */\n\n\n  Index.fromJSON = function (json) {\n    return Index.create(json.dimensions);\n  };\n\n  return Index;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["C:/Users/first/Desktop/numer/Numerpj/node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js"],"names":["isMatrix","isRange","clone","isInteger","factory","name","dependencies","createIndexClass","_ref","ImmutableDenseMatrix","Index","ranges","SyntaxError","_dimensions","_isScalar","i","ii","arguments","length","arg","push","Array","isArray","m","_createImmutableMatrix","valueOf","size","TypeError","prototype","type","isIndex","l","index","create","apply","d","max","values","range","min","forEach","callback","dimension","dim","isObjectProperty","getObjectProperty","isScalar","toArray","array","toString","strings","JSON","stringify","join","toJSON","mathjs","dimensions","fromJSON","json","isClass"],"mappings":"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","sourcesContent":["import { isMatrix, isRange } from '../../utils/is.js';\r\nimport { clone } from '../../utils/object.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'Index';\r\nvar dependencies = ['ImmutableDenseMatrix'];\r\nexport var createIndexClass = /* #__PURE__ */factory(name, dependencies, (_ref) => {\r\n  var {\r\n    ImmutableDenseMatrix\r\n  } = _ref;\r\n\r\n  /**\r\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\r\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\r\n   *\r\n   * Usage:\r\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\r\n   *\r\n   * Where each parameter can be any of:\r\n   *     A number\r\n   *     A string (containing a name of an object property)\r\n   *     An instance of Range\r\n   *     An Array with the Set values\r\n   *     A Matrix with the Set values\r\n   *\r\n   * The parameters start, end, and step must be integer numbers.\r\n   *\r\n   * @class Index\r\n   * @Constructor Index\r\n   * @param {...*} ranges\r\n   */\r\n  function Index(ranges) {\r\n    if (!(this instanceof Index)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    this._dimensions = [];\r\n    this._isScalar = true;\r\n\r\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\r\n      var arg = arguments[i];\r\n\r\n      if (isRange(arg)) {\r\n        this._dimensions.push(arg);\r\n\r\n        this._isScalar = false;\r\n      } else if (Array.isArray(arg) || isMatrix(arg)) {\r\n        // create matrix\r\n        var m = _createImmutableMatrix(arg.valueOf());\r\n\r\n        this._dimensions.push(m); // size\r\n\r\n\r\n        var size = m.size(); // scalar\r\n\r\n        if (size.length !== 1 || size[0] !== 1) {\r\n          this._isScalar = false;\r\n        }\r\n      } else if (typeof arg === 'number') {\r\n        this._dimensions.push(_createImmutableMatrix([arg]));\r\n      } else if (typeof arg === 'string') {\r\n        // object property (arguments.count should be 1)\r\n        this._dimensions.push(arg);\r\n      } else {\r\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\r\n      } // TODO: implement support for wildcard '*'\r\n\r\n    }\r\n  }\r\n  /**\r\n   * Attach type information\r\n   */\r\n\r\n\r\n  Index.prototype.type = 'Index';\r\n  Index.prototype.isIndex = true;\r\n\r\n  function _createImmutableMatrix(arg) {\r\n    // loop array elements\r\n    for (var i = 0, l = arg.length; i < l; i++) {\r\n      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {\r\n        throw new TypeError('Index parameters must be positive integer numbers');\r\n      }\r\n    } // create matrix\r\n\r\n\r\n    return new ImmutableDenseMatrix(arg);\r\n  }\r\n  /**\r\n   * Create a clone of the index\r\n   * @memberof Index\r\n   * @return {Index} clone\r\n   */\r\n\r\n\r\n  Index.prototype.clone = function () {\r\n    var index = new Index();\r\n    index._dimensions = clone(this._dimensions);\r\n    index._isScalar = this._isScalar;\r\n    return index;\r\n  };\r\n  /**\r\n   * Create an index from an array with ranges/numbers\r\n   * @memberof Index\r\n   * @param {Array.<Array | number>} ranges\r\n   * @return {Index} index\r\n   * @private\r\n   */\r\n\r\n\r\n  Index.create = function (ranges) {\r\n    var index = new Index();\r\n    Index.apply(index, ranges);\r\n    return index;\r\n  };\r\n  /**\r\n   * Retrieve the size of the index, the number of elements for each dimension.\r\n   * @memberof Index\r\n   * @returns {number[]} size\r\n   */\r\n\r\n\r\n  Index.prototype.size = function () {\r\n    var size = [];\r\n\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var d = this._dimensions[i];\r\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\r\n    }\r\n\r\n    return size;\r\n  };\r\n  /**\r\n   * Get the maximum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} max\r\n   */\r\n\r\n\r\n  Index.prototype.max = function () {\r\n    var values = [];\r\n\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var range = this._dimensions[i];\r\n      values[i] = typeof range === 'string' ? range : range.max();\r\n    }\r\n\r\n    return values;\r\n  };\r\n  /**\r\n   * Get the minimum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} min\r\n   */\r\n\r\n\r\n  Index.prototype.min = function () {\r\n    var values = [];\r\n\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var range = this._dimensions[i];\r\n      values[i] = typeof range === 'string' ? range : range.min();\r\n    }\r\n\r\n    return values;\r\n  };\r\n  /**\r\n   * Loop over each of the ranges of the index\r\n   * @memberof Index\r\n   * @param {Function} callback   Called for each range with a Range as first\r\n   *                              argument, the dimension as second, and the\r\n   *                              index object as third.\r\n   */\r\n\r\n\r\n  Index.prototype.forEach = function (callback) {\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      callback(this._dimensions[i], i, this);\r\n    }\r\n  };\r\n  /**\r\n   * Retrieve the dimension for the given index\r\n   * @memberof Index\r\n   * @param {Number} dim                  Number of the dimension\r\n   * @returns {Range | null} range\r\n   */\r\n\r\n\r\n  Index.prototype.dimension = function (dim) {\r\n    return this._dimensions[dim] || null;\r\n  };\r\n  /**\r\n   * Test whether this index contains an object property\r\n   * @returns {boolean} Returns true if the index is an object property\r\n   */\r\n\r\n\r\n  Index.prototype.isObjectProperty = function () {\r\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\r\n  };\r\n  /**\r\n   * Returns the object property name when the Index holds a single object property,\r\n   * else returns null\r\n   * @returns {string | null}\r\n   */\r\n\r\n\r\n  Index.prototype.getObjectProperty = function () {\r\n    return this.isObjectProperty() ? this._dimensions[0] : null;\r\n  };\r\n  /**\r\n   * Test whether this index contains only a single value.\r\n   *\r\n   * This is the case when the index is created with only scalar values as ranges,\r\n   * not for ranges resolving into a single value.\r\n   * @memberof Index\r\n   * @return {boolean} isScalar\r\n   */\r\n\r\n\r\n  Index.prototype.isScalar = function () {\r\n    return this._isScalar;\r\n  };\r\n  /**\r\n   * Expand the Index into an array.\r\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\r\n\r\n\r\n  Index.prototype.toArray = function () {\r\n    var array = [];\r\n\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var dimension = this._dimensions[i];\r\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\r\n    }\r\n\r\n    return array;\r\n  };\r\n  /**\r\n   * Get the primitive value of the Index, a two dimensional array.\r\n   * Equivalent to Index.toArray().\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\r\n\r\n\r\n  Index.prototype.valueOf = Index.prototype.toArray;\r\n  /**\r\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\r\n   * @memberof Index\r\n   * @returns {String} str\r\n   */\r\n\r\n  Index.prototype.toString = function () {\r\n    var strings = [];\r\n\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var dimension = this._dimensions[i];\r\n\r\n      if (typeof dimension === 'string') {\r\n        strings.push(JSON.stringify(dimension));\r\n      } else {\r\n        strings.push(dimension.toString());\r\n      }\r\n    }\r\n\r\n    return '[' + strings.join(', ') + ']';\r\n  };\r\n  /**\r\n   * Get a JSON representation of the Index\r\n   * @memberof Index\r\n   * @returns {Object} Returns a JSON object structured as:\r\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   */\r\n\r\n\r\n  Index.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'Index',\r\n      dimensions: this._dimensions\r\n    };\r\n  };\r\n  /**\r\n   * Instantiate an Index from a JSON object\r\n   * @memberof Index\r\n   * @param {Object} json A JSON object structured as:\r\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   * @return {Index}\r\n   */\r\n\r\n\r\n  Index.fromJSON = function (json) {\r\n    return Index.create(json.dimensions);\r\n  };\r\n\r\n  return Index;\r\n}, {\r\n  isClass: true\r\n});"]},"metadata":{},"sourceType":"module"}